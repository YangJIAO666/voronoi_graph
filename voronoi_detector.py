"""
优化后的Voronoi社区检测器
使用igraph实现核心算法，大幅提升速度
"""

import networkx as nx
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib.cm as cm
import heapq
import scipy.optimize as optimize
import os
import igraph as ig

from modularity import calculate_newman_modularity

class VoronoiCommunityDetector:

    
    def __init__(self, graphml_path):
        """
        Initialize the detector by directly loading the GraphML file
        """
        self.graphml_path = graphml_path
        self.G = self._load_graph()
        self.edge_lengths = {}
        self.local_density = {}
        self.generators = []
        self.communities = {}
        self.optimal_R = None
        
        self._extract_edge_lengths()
        
        self._convert_to_igraph()
        
    def _load_graph(self):
        """Load the GraphML file generated by GenerateGraph.py"""
        if not os.path.exists(self.graphml_path):
            raise FileNotFoundError(f"GraphML file not found: {self.graphml_path}")
        
        G = nx.read_graphml(self.graphml_path)
        G = G.to_undirected()
        
        return G
        
    def _extract_edge_lengths(self):
        """Extract edge lengths, directly using the 'weight' attribute from the GraphML as length"""
        for u, v, data in self.G.edges(data=True):
            weight = float(data.get('weight', 1.0))
            length = weight
            
            self.edge_lengths[(u, v)] = length
            self.edge_lengths[(v, u)] = length  # Undirected graph symmetry
    
    def _convert_to_igraph(self):
        """Convert NetworkX graph to igraph format"""
        self.node_list = list(self.G.nodes())
        self.node_to_idx = {node: i for i, node in enumerate(self.node_list)}
        self.n_nodes = len(self.node_list)
        
        edges = []
        weights = []
        for u, v in self.G.edges():
            edges.append((self.node_to_idx[u], self.node_to_idx[v]))
            weights.append(self.edge_lengths[(u, v)])
        
        self.ig_graph = ig.Graph(edges=edges, directed=False)
        self.ig_graph.es['weight'] = weights

    def calculate_local_relative_density(self):
        """
        Using igraph's adjacency operations, much faster than NetworkX
        """
        local_density = {}
        
        for i in range(self.n_nodes):
            node = self.node_list[i]
            neighbors_idx = self.ig_graph.neighbors(i)
            
            if not neighbors_idx:
                local_density[node] = 0
                continue
            
            neighbors_set = set(neighbors_idx)
            
            m = 0
            for j, u in enumerate(neighbors_idx):
                for v in neighbors_idx[j+1:]:
                    if self.ig_graph.are_connected(u, v):
                        m += 1
            
            k = 0
            for u in neighbors_idx:
                for v in self.ig_graph.neighbors(u):
                    if v != i and v not in neighbors_set:
                        k += 1
            
            if m + k == 0:
                density = 0
            else:
                density = m / (m + k)
            
            local_density[node] = density
        
        return local_density

    def calculate_weighted_local_density(self):
        """Calculate weighted local relative density (igraph optimized)"""
        local_density = self.calculate_local_relative_density()
        
        strength = {}
        EPS = 0.01
        
        for i in range(self.n_nodes):
            node = self.node_list[i]
            s = 0.0
            
            for neighbor_idx in self.ig_graph.neighbors(i):
                edge_id = self.ig_graph.get_eid(i, neighbor_idx)
                d = self.ig_graph.es[edge_id]['weight']
                w = 1.0 / (d + EPS)
                s += w
            
            strength[node] = s
        
        weighted_density = {}
        for node in self.node_list:
            weighted_density[node] = local_density[node] * strength[node]
        
        self.local_density = weighted_density

    def choose_generators(self, radius):
        """Choose generator nodes (igraph optimized)"""
        sorted_nodes = sorted(self.local_density.items(), key=lambda x: x[1], reverse=True)
        
        generators = []
        excluded = set()
        
        for node, _ in sorted_nodes:
            if node not in excluded:
                generators.append(node)
                
                node_idx = self.node_to_idx[node]
                distances = self.ig_graph.shortest_paths(source=node_idx, weights='weight')[0]
                
                for i, dist in enumerate(distances):
                    if dist <= radius:
                        excluded.add(self.node_list[i])
                
                if len(excluded) == len(self.G.nodes()):
                    break
        
        return generators

    def voronoi_community_detection(self, radius=None):
        """
        Perform Voronoi community detection (igraph optimized)
        """
        if not self.local_density:
            self.calculate_weighted_local_density()
        
        if radius is None:
            radius = 10.0
        
        generators = self.choose_generators(radius)
        
        if len(generators) == 0:
            return {}, [], radius
        
        generator_indices = [self.node_to_idx[gen] for gen in generators]
        
        all_distances = self.ig_graph.shortest_paths(
            source=generator_indices, 
            weights='weight'
        )
        
        communities = {}
        for i in range(self.n_nodes):
            min_dist = float('inf')
            closest_generator = None
            
            for gen_idx in range(len(generators)):
                dist = all_distances[gen_idx][i]
                if dist < min_dist:
                    min_dist = dist
                    closest_generator = gen_idx
            
            node = self.node_list[i]
            if closest_generator is not None:
                communities[node] = closest_generator
            else:
                communities[node] = -1
        
        return communities, generators, radius

    def calculate_modularity(self, communities):
        """Calculate modularity"""
        return calculate_newman_modularity(self.G, communities)


def test_optimized_voronoi():
    """
    Test the optimized Voronoi community detection
    """
    import time
    
    graphml_path = "output_socioeconomic_new/final_weighted_graph.graphml"
    
    
    times = []
    n_runs = 10
    
    for i in range(n_runs):
        start = time.time()
        
        detector = VoronoiCommunityDetector(graphml_path)
        communities, generators, R = detector.voronoi_community_detection(radius=2.6)
        
        elapsed = time.time() - start
        times.append(elapsed)
        
        n_comm = len(set(communities.values()) - {-1})
    
    
    return times


if __name__ == "__main__":
    test_optimized_voronoi()
